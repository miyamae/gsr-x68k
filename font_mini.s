*********************************************************
*
*
*
*	３(4)＊５超小型７セグメント数値表示
*
*
*			Programmed by T.MIYAMAE
*
*
*
*********************************************************

	.include	iocscall.mac
	.include	doscall.mac

*---------------------------------------*

R21		equ	$e8002a
R23		equ	$e8002e
TVRAM		equ	$e00000

*---------------------------------------*

	.xdef	print_mini

	.text
	.even

*********************************************************
*
*	表示ルーチン	print_mini
*			入力	d6.w=Ｘ座標（４ドット単位）
*				d7.w=Ｙ座標（１ドット単位）
*				a6.l=表示文字列先頭
*
*********************************************************
print_mini:
	movem.l	d0-d7/a0-a6,-(sp)
	move.w	#%11110000_11110000,R23	;ビットマスク設定
*---------------------------------------*
*アドレス計算
	divu.w	#2,d6
	movea.l	#TVRAM,a1
	lsl.w	#7,d7			;Ｙ座標＊１０２４／８
	add.w	d6,d7
	adda.l	d7,a1			;a1.l=書き始めアドレス
*---------------------------------------*
	swap.w	d6
	tst.w	d6			;Ｘ座標が偶数だったら
	bne	ptn2
*---------------------------------------*
f_loop:
	tst.b	(a6)			;エンドコードを見つけたら終わり
	beq	f_break

	lea.l	font_data,a2
	moveq.l	#0,d1
	move.b	(a6)+,d1
	cmp.b	#' ',d1			;スペースか？
	beq	@f
	subi.w	#',',d1			;文字コード -> バイナリ変換
	mulu.w	#5,d1
	adda.l	d1,a2
@@:
	move.b	(a2),(a1)		;テキスト書き込み（バイト上位）
	move.b	1(a2),1024/8(a1)
	move.b	2(a2),1024/8*2(a1)
	move.b	3(a2),1024/8*3(a1)
	move.b	4(a2),1024/8*4(a1)

*---------------------------------------*

	tst.b	(a6)			;エンドコードを見つけたら終わり
	beq	f_break

	lea.l	font_data,a2
	moveq.l	#0,d1
	move.b	(a6)+,d1
	cmp.b	#' ',d1			;スペースか？
	beq	@f
	subi.w	#',',d1			;文字コード -> バイナリ変換
	mulu.w	#5,d1
	adda.l	d1,a2
@@:
	bset	#9,R21			;ビットマスクＯＮ
					;テキスト書き込み（バイト下位）
	move.b	(a2),d1			;・d1にパターンを取り出して
	ror.b	#4,d1			;・右側に動かして
	move.b	d1,(a1)			;・テキストに書き込む
	move.b	1(a2),d1		;	:
	ror.b	#4,d1			;	:
	move.b	d1,1024/8(a1)
	move.b	2(a2),d1
	ror.b	#4,d1
	move.b	d1,1024/8*2(a1)
	move.b	3(a2),d1
	ror.b	#4,d1
	move.b	d1,1024/8*3(a1)
	move.b	4(a2),d1
	ror.b	#4,d1
	move.b	d1,1024/8*4(a1)
	bclr	#9,R21			;ビットマスクＯＦＦ

	addq.l	#1,a1			;書き始めアドレスを進める
	bra	f_loop

*---------------------------------------*
*バイト下位からのときの場合
ptn2:
	tst.b	(a6)			;エンドコードを見つけたら終わり
	beq	f_break

	lea.l	font_data,a2
	moveq.l	#0,d1
	move.b	(a6)+,d1
	cmp.b	#' ',d1			;スペースか？
	beq	@f
	subi.w	#',',d1			;文字コード -> バイナリ変換
	mulu.w	#5,d1
	adda.l	d1,a2
@@:
	bset	#9,R21			;ビットマスクＯＮ
	move.b	(a2),d1			;テキスト書き込み
	ror.b	#4,d1
	move.b	d1,(a1)
	move.b	1(a2),d1
	ror.b	#4,d1
	move.b	d1,1024/8(a1)
	move.b	2(a2),d1
	ror.b	#4,d1
	move.b	d1,1024/8*2(a1)
	move.b	3(a2),d1
	ror.b	#4,d1
	move.b	d1,1024/8*3(a1)
	move.b	4(a2),d1
	ror.b	#4,d1
	move.b	d1,1024/8*4(a1)
	bclr	#9,R21			;ビットマスクＯＦＦ

	addq.l	#1,a1			;書き始めアドレスを進める
	bra	f_loop

*---------------------------------------*
f_break:
	movem.l	(sp)+,d0-d7/a0-a6
	rts

*********************************************************
*
*	フォントデータ
*
*********************************************************
	.data
	.even
font_data:

	.dc.b	%0_0_0_0__0000	;
	.dc.b	%0_0_0_0__0000
	.dc.b	%0_0_0_0__0000
	.dc.b	%0_0_0_0__0000
	.dc.b	%0_0_0_0__0000

	.dc.b	%0_0_0_0__0000	;-
	.dc.b	%0_0_0_0__0000
	.dc.b	%1_1_1_0__0000
	.dc.b	%0_0_0_0__0000
	.dc.b	%0_0_0_0__0000

	.dc.b	%1_0_1_0__0000	;H(.)
	.dc.b	%1_0_1_0__0000
	.dc.b	%1_1_1_0__0000
	.dc.b	%1_0_1_0__0000
	.dc.b	%1_0_1_0__0000

	.dc.b	%0_0_0_0__0000	;
	.dc.b	%0_0_0_0__0000
	.dc.b	%0_0_0_0__0000
	.dc.b	%0_0_0_0__0000
	.dc.b	%0_0_0_0__0000

	.dc.b	%1_1_1_0__0000	;0
	.dc.b	%1_0_1_0__0000
	.dc.b	%1_0_1_0__0000
	.dc.b	%1_0_1_0__0000
	.dc.b	%1_1_1_0__0000

	.dc.b	%0_1_0_0__0000	;1
	.dc.b	%0_1_0_0__0000
	.dc.b	%0_1_0_0__0000
	.dc.b	%0_1_0_0__0000
	.dc.b	%0_1_0_0__0000

	.dc.b	%1_1_1_0__0000	;2
	.dc.b	%0_0_1_0__0000
	.dc.b	%1_1_1_0__0000
	.dc.b	%1_0_0_0__0000
	.dc.b	%1_1_1_0__0000

	.dc.b	%1_1_1_0__0000	;3
	.dc.b	%0_0_1_0__0000
	.dc.b	%1_1_1_0__0000
	.dc.b	%0_0_1_0__0000
	.dc.b	%1_1_1_0__0000

	.dc.b	%1_0_1_0__0000	;4
	.dc.b	%1_0_1_0__0000
	.dc.b	%1_1_1_0__0000
	.dc.b	%0_0_1_0__0000
	.dc.b	%0_0_1_0__0000

	.dc.b	%1_1_1_0__0000	;5
	.dc.b	%1_0_0_0__0000
	.dc.b	%1_1_1_0__0000
	.dc.b	%0_0_1_0__0000
	.dc.b	%1_1_1_0__0000

	.dc.b	%1_1_1_0__0000	;6
	.dc.b	%1_0_0_0__0000
	.dc.b	%1_1_1_0__0000
	.dc.b	%1_0_1_0__0000
	.dc.b	%1_1_1_0__0000

	.dc.b	%1_1_1_0__0000	;7
	.dc.b	%0_0_1_0__0000
	.dc.b	%0_0_1_0__0000
	.dc.b	%0_0_1_0__0000
	.dc.b	%0_0_1_0__0000

	.dc.b	%1_1_1_0__0000	;8
	.dc.b	%1_0_1_0__0000
	.dc.b	%1_1_1_0__0000
	.dc.b	%1_0_1_0__0000
	.dc.b	%1_1_1_0__0000

	.dc.b	%1_1_1_0__0000	;9
	.dc.b	%1_0_1_0__0000
	.dc.b	%1_1_1_0__0000
	.dc.b	%0_0_1_0__0000
	.dc.b	%1_1_1_0__0000

	.end
